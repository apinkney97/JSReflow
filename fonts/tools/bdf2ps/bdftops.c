/*
 *
 * File:         bdftops.c
 * Description:  Make a Postscript font from a BDF font
 * Author:       Mark Leisher
 * Created:      Mon Nov 19 10:27:38 1990
 * Modified:     Mon Nov 19 10:27:42 1990
 *
 */

/*
 * Copyright (C) 1990 Mark Leisher.
 *
 * Author: Mark Leisher (mleisher@nmsu.edu)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 1, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * A copy of the GNU General Public License can be obtained from this
 * program's author (send electronic mail to mleisher@nmsu.edu) or from
 * the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
 * 02139, USA.
 *
 */

#include <stdio.h>
#include <X11/Xos.h>
#include "patchlevel.h"

#define BDFTOPS_VERSION 1
#define AUTHOR_STRING "mleisher@nmsu.edu (Mark Leisher)"
#define BDF_VERSION "2.1"

char *program, *fontname;
char buff[128];
int fontno = 1;

int w, h, psize, resX, resY;
double width_scale;

char *
get_fontname(str)
char *str;
{
    int len;
    char *ptr, *tmp_name;

    if (str == NULL) {
        tmp_name = (char *)malloc(20 * sizeof(char));
        sprintf(tmp_name, "BDF FONT %d", fontno++);
        return(tmp_name);
    }
    len = strlen(str);
    ptr = str + (len - 1);
    while(ptr > str && *ptr != '.')
      ptr--;
    if (ptr == str)
      return(str);
    ptr++;
    if (!strncmp(ptr, "bdf", 3)) {
        ptr--;
        tmp_name = (char *)malloc(((ptr-str) + 1) * sizeof(char));
        strncpy(tmp_name, str, (ptr-str));
        tmp_name[ptr-str] = '\0';
        return(tmp_name);
    }
    return(str);
}

void
header(in)
FILE *in;
{
    int dx, dy;
    int i, count, ndx, ndy;
    double llx, lly, urx, ury;
    time_t clock;

    printf("%%!PS-Adobe-2.0\n");
    printf("%%%% GENERATED BY \"bdftops %d.%d\"\n", BDFTOPS_VERSION,
           patchlevel);
    printf("%%%% AUTHOR %s\n", AUTHOR_STRING);

    time(&clock);
    printf("%%%% DATE %s\n", ctime(&clock));

    printf("10 dict dup begin\n");
    printf("/FontType 3 def\n");
    printf("/FontMatrix [1 0 0 1 0 0] def\n");

    fscanf(in, "%[^\n]\n", buff);

    if (strcmp(buff, "STARTFONT 2.1")) {
        fprintf(stderr, "%s: incorrect BDF format \"%s\"\n", program,
                buff);
        exit(1);
    }

    while(!feof(in) && strncmp(buff, "SIZE", 4))
      fscanf(in, "%[^\n]\n", buff);
    if (strncmp(buff, "SIZE", 4)) {
        fprintf(stderr, "%s: missing SIZE\n", program);
        exit(1);
    }
    sscanf(buff, "SIZE %d %d %d", &psize, &resX, &resY);

    width_scale = (((double)psize)/1000.0) * (((double)resX)/72.27);

    while(!feof(in) && strncmp(buff, "FONTBOUNDINGBOX", 15))
      fscanf(in, "%[^\n]\n", buff);
    if (strncmp(buff, "FONTBOUNDINGBOX", 15)) {
        fprintf(stderr, "%s: missing FONTBOUNDINGBOX\n", program);
        exit(1);
    }
    sscanf(buff, "FONTBOUNDINGBOX %d %d %d %d", &w, &h, &dx, &dy);

    ndx = (dx < 0) ? -(dx) : dx;
    ndy = (dy < 0) ? -(dy) : dy;
    if (w == 0)
      llx = urx = 0.0;
    else {
        llx = ((double)(w + ndx)) / ((double) w);
        urx = ((double) dx) / ((double) w);
    }
    if (h == 0)
      lly = ury = 0.0;
    else {
        lly = ((double)(h + ndy)) / ((double) h);
        ury = ((double) dy) / ((double) h);
    }
    printf("/FontBBox [%g %g %g %g] def\n", llx, lly, urx, ury);
    printf("/Encoding 256 array def\n");
    printf("0 1 255 {Encoding exch /.notdef put} for\n");
    printf("Encoding\n");
    count = 0;
    for (i = 32; i < 255; i++) {
        printf("dup %d /char%d put\t", i, i);
        count++;
        if (count % 3 == 0) {
            count = 0;
            printf("\n");
        }
    }
    printf("255 /char255 put\n");
    printf("/BuildChar\n{0 begin\n/char exch def\n/fontdict exch def\n");
    printf("/charname fontdict /Encoding get char get def\n");
    printf("/charinfo fontdict /CharData get charname get def\n");
    printf("/wx charinfo 0 get def\n");
    printf("/charbbox charinfo 1 4 getinterval def\n");
    printf("wx 0 charbbox aload pop setcachedevice\n");
    printf("charinfo 5 get charinfo 6 get true\n");
    printf("fontdict /imagemaskmatrix get\n");
    printf("dup 4 charinfo 7 get put\n");
    printf("dup 5 charinfo 8 get put\n");
    printf("charinfo 9 1 getinterval cvx imagemask\n");
    printf("end } def\n");
    printf("/BuildChar load 0 6 dict put\n");
    printf("/imagemaskmatrix [%d 0 0 -%d 0 0] def\n", w, h);
    printf("/CharData 224 dict def\nCharData begin\n");
}

void
gen_chars(in)
FILE *in;
{
    int cw, ch, dx, dy, dx1, dy1, encoding, i;
    int sw, dummy;
    double wx, llx, lly, urx, ury, ndx, ndy, tdx;

    fscanf(in, "%[^\n]\n", buff);
    while(!feof(in)) {
        while(!feof(in) && strncmp(buff, "ENCODING", 8))
          fscanf(in, "%[^\n]\n", buff);
        if (feof(in))
          break;
        sscanf(buff, "ENCODING %d", &encoding);

        while(!feof(in) && strncmp(buff, "SWIDTH", 6))
          fscanf(in, "%[^\n]\n", buff);
        if (feof(in))
          break;
        sscanf(buff, "SWIDTH %d %d", &sw, &dummy);

        sw = (int)(((double)sw) * width_scale);
        sw++;

        if (!feof(in) && encoding >= 32) {
            while(!feof(in) && strncmp(buff, "BBX", 3))
              fscanf(in, "%[^\n]\n", buff);
            if (feof(in))
              break;
            sscanf(buff, "BBX %d %d %d %d", &cw, &ch, &dx, &dy);
            dx1 = (dx < 0) ? -(dx) : dx;
            dy1 = (dy < 0) ? -(dy) : dy;
            ndx = 2.0 * (((double) dx1) - 0.5);
            wx = (((double) sw) + ndx) / ((double) w);
            if (wx == 0)
              wx = ((double)w) * 0.01;
            if (w == 0)
              llx = urx = 0.0;
            else {
                urx = ((double)(sw + dx1)) / ((double) sw);
                llx = ((double) dx) / ((double) sw);
            }
            if (h == 0)
              lly = ury = 0.0;
            else {
                ury = ((double)(ch + dy1)) / ((double) ch);
                lly = ((double) dy) / ((double) ch);
            }
            ndx = ((double)dx1) - 0.5;
            ndy = ((double)ch) - 0.5;
            printf("/char%d [%g %g %g %g %g %d %d %g %g\n<", encoding, wx, llx,
                   lly, urx, ury, cw, ch, ndx, ndy);

            fscanf(in, "%[^\n]\n", buff);
            while(!feof(in) && strncmp(buff, "BITMAP", 6))
              fscanf(in, "%[^\n]\n", buff);
            if (feof(in))
              break;
            for (i = 0; i < ch; i++) {
                fscanf(in, "%[^\n]", buff);
                printf("%s", buff);
                getc(in);  /* kill the EOL */
            }
            printf(">] def\n");
        } else
          fscanf(in, "%[^\n]\n", buff);
    }
    printf("/.notdef [%g 0 0 0 0 1 0 0 <>] def\n", ((double) w) * .01);
    printf("end\nend\n/%s exch definefont pop\n", fontname);
}


main(argc, argv)
int argc;
char **argv;
{
    FILE *in = stdin;

    program = argv[0];

    argc--;
    *argv++;
    while(argc) {
        if (!(in = fopen(argv[0], "r")))
          fprintf(stderr, "%s: problem with %s\n", program, argv[0]);
        else {
            fontname = get_fontname(argv[0]);
            header(in);
            gen_chars(in);
            fclose(in);
            in = NULL;
        }
        argc--;
        *argv++;
    }
    if (in != NULL) {
        header(in);
        gen_chars(in);
    }
}
