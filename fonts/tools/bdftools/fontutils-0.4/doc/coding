All .c files include config.h first, which includes global.h, which
includes types.h and ... 

.h files do not include config.h.  They only include whatever header
files they need to declare what is mentioned in themselves -- typically,
types.h.

The main program is always in main.c.  Typically it includes a
loop through all the characters in the input font, and doing something
with them.  Parsing arguments is done there, also.

The configure script is generated by autoconf from configure.in.  When
configure runs, it writes out the definitions into include/config-auto.h
(which config.h includes).

Virtually all .c files -- only exceptions are (sometimes) main.c and a
few library files -- have a corresponding .h file, which defines all the
public routines/types/whatever.  Comments in the .h file try to explain
what a routine does; comments in the .c file assume you already know
that (to avoid having the same information in two places), and try to
explain only implementation details.

A .c file should always include its corresponding .h file, to ensure
consistency between the definitions and the declarations.

Virtually all structure types have their members accessed by macros
instead of with `.' or `->' directly.  Whole structures are passed and
returned without hesitation; this has not resulted in any noticeable
performance loss.  When I use pointers to structures, it's almost always
because I need a distinguishable value (i.e., NULL).

When a function has no side effects (e.g., assignments to global
variables), and does not examine any values except its arguments (e.g.,
if a pointer is passed, it does not examine the data pointed to),
declare it const.  (This is a GNU C extension.)

All programs use getopt_long_only to parse arguments.  Certain options
are common to most programs:
-help		usage message
-verbose	brief status reporting; e.g., print each
		  character code as it is processed
-log		long, detailed, status reporting, written to a file
-version	print program version
